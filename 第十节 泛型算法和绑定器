#include<iostream>
#include<vector>
#include<algorithm>
#include<functional>
using namespace std;

int main() {
	int arr[] = { 12, 4, 78, 9, 21, 43, 56, 52, 42, 31 };
	//将数组中的元素拷贝进入vector容器
	vector<int> vec(arr, arr + sizeof(arr) / sizeof(arr[0]));

	for (int v : vec) {
		cout << v << " ";
	}
	cout << endl;
	
	//默认从小到大的排序
	sort(vec.begin(), vec.end());
	for (int v : vec) {
		cout << v << " ";
	}
	cout << endl;

	//有序容器中进行二分查找 效率更高 O(logN)
	if (binary_search(vec.begin(), vec.end(), 21)) {
		cout << "21存在" << endl;
	}

	//如果找到返回迭代器 否则返回vec.end() O(N)
	auto it1 = find(vec.begin(), vec.end(), 21);
	if (it1 != vec.end()) {
		cout << "21存在" << endl;
	}

	//从大到小的排序 默认是less 使用的是快速排序
	sort(vec.begin(), vec.end(), greater<int>());
	for (int v : vec) {
		cout << v << " ";
	}
	cout << endl;

	//78 56 52 43 42 31 21 12 9 4
	//按条 件查找 将48按顺序插入vector容器中
	//find_if是在容器中找第一个小于48的元素 需要一个一元函数对象
	//bind1st：把二元函数对象的operator()的第一个参数绑定起来
	//bind2nd：把二元函数对象的operator()的第二个参数绑定起来
	//绑定器 + 二元函数对象 => 一元函数对象
	//(1)使用 greater  a > b 应该把a绑定为48 将容器中的元素传给b a绑定为48
	//auto it2 = find_if(vec.begin(), vec.end(), bind1st(greater<int>(), 48));
	//(2)使用 less a < b(48)
	//auto it2 = find_if(vec.begin(), vec.end(), bind2nd(less<int>(), 48));
	//(3)使用lambda表达式 []表示捕获外部变量 ()表示形参变量 -> 表示返回对象
	auto it2 = find_if(vec.begin(), vec.end(), [](int val)->bool {return val < 48; });
	vec.insert(it2, 48);
	for (int v : vec) {
		cout << v << " ";
	}
	cout << endl;

	//for_each可以遍历容器的所有元素 可以自行添加合适的函数对象
	//过滤容器中的元素
	for_each(vec.begin(), vec.end(), 
		[](int val)->void
		{
		if (val % 2 == 0) {
			cout << val << " ";
			}
		});
	cout << endl;

	return 0;
} 
