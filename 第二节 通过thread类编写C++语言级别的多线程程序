#include<iostream>
#include<thread>
using namespace std;

/*C++语言级别的多线程 => 代码可以跨平台 windows/linux/mac
否则只能调用系统API 只能本地使用

thread-> mutex->线程间的互斥 condition_variable->线程间通信
lock_quard/unique_lock 自动加锁解锁
atomic 原子类型 基于CAS操作的原子类型 线程安全的
sleep_for 睡眠

		C++语言层面 thread
		windows            linux   strace ./a.out
		   |                 |
	  createThread      pthread_create

线程内容1：如何创建启动一个线程?
使用std::thread定义一个线程对象，传入线程所需要的线程函数和参数，线程自动开启

线程内容2：子线程如何结束？
子线程运行完成，线程就结束了

线程内容3：主线程如何处理子线程
t.join() ：等待t线程结束，当前线程才能继续网线运行
t.detach：把t线程设置为分离线程，主线程结束，整个进程就结束了，所有子线程自动就结束了
*/

//子线程1
void threadHandle1(int time) {
	//this_thread->namespace 里面有一些方法 yield()->放弃当前时间片 sleep_for->睡多久
	//sleep_for下有一个chrono 也是namespace 里面定义了与时间相关的常量和方法
	//std::chrono::seconds(2)表示运行时让子线程睡眠2秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread1!" << endl;
}

//子线程1
void threadHandle2(int time) {
	//this_thread->namespace 里面有一些方法 yield()->放弃当前时间片 sleep_for->睡多久
	//sleep_for下有一个chrono 也是namespace 里面定义了与时间相关的常量和方法
	//std::chrono::seconds(2)表示运行时让子线程睡眠2秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread2!" << endl;
}

int main() {
	//创建了一个线程对象 传入一个线程函数 新线程就开始运行了
	//可以将睡眠时间作为参数传入 在构造函数中已经完成了封装 可以传任意多参数
	//在创建进程函数多少实参 就要在线程函数添加多少形参来接受
	thread t1(threadHandle1, 2);
	thread t2(threadHandle2, 3);

	//主线程必须等待子线程结束 才能继续往下运行 当主线程运行时 不能存在其他未完成的子线程
	t1.join();
	t2.join();

	//将子线程设置为分离线程 主线程完了就结束了 不会等待子线程
	//t1.detach();

	cout << "main thread done!" << endl;

	//主线程运行完成 查看如果当前进程还有未运行完成的子线程
	//进程就会异常终止
	return 0;
}
