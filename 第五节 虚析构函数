#include<iostream>
#include<typeinfo>
#include<string>
using namespace std;

/*
问题一：哪些函数不能实现成虚函数？
1.虚函数能产生地址，存储在vftable当中
2.对象必须存在(vfptr->vftable->虚函数地址)

构造函数
1.virtual+构造函数是不可以的
2.构造函数中调用虚函数，也不会发生动态绑定。虚函数中调用任何函数都是静态绑定的

静态成员方法不可以成为虚函数: virtual + static

问题二：虚析构函数 析构函数调用的时候 对象是存在的
什么时候把基类的析构函数实现成虚函数？
基类指针/引用指向堆上new出来的派生类对象时 delete pb(基类指针)
它调用析构函数的时候 必须发生动态绑定 否则会导致派生类的析构函数无法调用
*/

class Base {
public:
	Base(int data) : ma(data) { cout << "Base()" << endl; }
	virtual ~Base() { cout << "~Base()" << endl; }
	virtual void show() { cout << "call Base::show" << endl; }

protected:
	int ma;
};//Base::~Base Base::show()

class Derive : public Base {
public:
	Derive(int data) : Base(ma), mb(data), ptr(new int(data)) { cout << "Derive()" << endl; }
	~Derive() { cout << "~Derive()" << endl; }

protected: 
	int mb;
	int* ptr;
};


int main() {
	/*Derive d(10);
	Base* pb = &d;
	pb->show();*/

	Base* pb = new Derive(10);
	pb->show(); //动态绑定*pb->Derive
	delete pb; //释放内存 派生类析构函数没有调用
	/*
	pb->Base类型 调用Base::~Base()析构函数 是静态绑定
	所以要将基类的析构函数变为虚析构函数 派生类也就自动成为虚函数了

	此时，
	pb->Base Base::~Base发现是virtual 此时会发生动态绑定
	pb指向Derive类型对象 最后访问的也是Derive的虚函数表 派生类析构函数负责析构自己的部分 再调用基类析构函数 把基类继承的成员释放
	*/
	return 0;
}
