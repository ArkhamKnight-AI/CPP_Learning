#include<iostream>
#include<functional> //函数对象
#include<algorithm> //泛型算法
#include<vector>
#include<ctime>
using namespace std;

/*
C++ STL中的绑定器
bind1st:operator() 的第一个形参变量绑定成一个确定的值
bind2nd:operator() 的第二个形参变量绑定成一个确定的值
*/

template<typename Container>
void showContainer(Container& con) {
	//告知编译器 无论用什么容器类型实例化 都有一个iterator迭代器 Container作用域下的iterator是一个类型名
	//否则编译器不知道iterator是一个类型还是变量
	typename Container::iterator it = con.begin();
	for (; it != con.end(); it++) {
		cout << *it << " ";
	}

	cout << endl;
}

//Iterator自定义迭代器 Compare比较规则
//从Iterator first开始遍历到Iterator last
//find_if是一个一元函数对象 要拿一个元素与指定的元素进行比较
template<typename Iterator, typename Compare>
Iterator my_find_if(Iterator first, Iterator last, Compare comp) {
	for (; first != last; first++) {

		//找到了 返回当前元素
		if (comp(*first)) { //调用了comp.operator()(*first)	小括号运算符重载 从容器中取一个参数传进来
			return first;
		}
	}

	return last;
}

//实现一元函数对象
template<typename Compare, typename T>
class _mybind1st {
public:
	//构造函数
	_mybind1st(Compare comp, T val)
		: _comp(comp), _val(val) {}

	//()运算符重载函数 第一个值被绑定了 需要第二个值
	bool operator()(const T& second) {
		//封装 底层做事情的还是二元函数对象 第二个参数是从外界接受的参数
		//第一个参数是通过构造函数传入的val值 即绑定的值
		//第二个参数是一元函数对象从外界传入的值 即容器中的元素
		return _comp(_val, second);
	}

private:
	Compare _comp;
	T _val;
};

//自定义绑定器 传入参数是一个二元函数对象 和 一个元素类型T
//需要返回一个一元函数对象 函数对象的名字是 mybind1st 
//mybind1st(Compare comp, const T& val)
template <typename Compare, typename T>
_mybind1st<Compare, T> mybind1st(Compare comp, const T& val) {
	//直接使用函数模板 好处是 可以进行类型推演
	return _mybind1st<Compare, T>(comp, val);
}

int main()
{
	vector<int> vec;
	srand(time(nullptr)); //设置随机数种子 要包含ctime头文件

	for (int i = 0; i < 20; i++) {
		vec.push_back(rand() % 100 + 1);
	}

	sort(vec.begin(), vec.end()); //默认小到大排序
	showContainer(vec);

	sort(vec.begin(), vec.end(), greater<int>()); //从大到小排序 二元函数对象
	showContainer(vec);

	auto it = my_find_if(vec.begin(), vec.end(), mybind1st(greater<int>(), 70));

	if (it != vec.end()) {
		vec.insert(it, 70);
	}
	showContainer(vec);

	return 0;
}
