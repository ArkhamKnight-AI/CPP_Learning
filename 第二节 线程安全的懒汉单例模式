#include<iostream>
#include<thread>
#include<atomic>  //包含很多原子类型
#include<mutex>
using namespace std;

/*
单例模式：一个类不管创建多少次对象，永远只能得到该类型一个对象的实例
A *p1 = new A();
A *p2 = new A();
A *p3 = new A();

常用到的 比如：
(1)日志模块：不能每次写日志都创建一个对象 否则会占用很大内存
(2)数据库模块：只要调用数据库模块的一个对象 不能因为每次有请求就创建一个数据库对象
*/

#if 0
//饿汉式单例模式 落在类作用域中的全局变量 是线程安全的 因为数据段在main函数前已经创建、初始化好的
//坏处：可能根本不需要这个对象 但还是构造了 且构造开销大
class Singleton {
public:
	static Singleton* getInstance() { //3.获取类的唯一实例对象的接口方法 
		return &instance;
	}

private:
	static Singleton instance;   //2.定义一个唯一的类的实例对象
	Singleton() { //1.构造函数私有化

	}

	//为了防止产生其他实例 拷贝构造函数和 =运算符重载函数 也需要限制 delete掉
	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};
//静态成员变量 类内定义 类外初始化 在数据段上 
Singleton Singleton::instance;
std::mutex mtx;


//懒汉式单例模式  ->  线程安全的懒汉式单例模式
class Singleton {
public:
	static Singleton* getInstance() { //3.获取类的唯一实例对象的接口方法 
		//保证多线程执行的安全 考虑了多线程未考虑单线程 单线程没必要(锁的粒度太大了)
		//lock_guard<std::mutex> guard(mtx); 
		if (instance == nullptr) {
			lock_guard<std::mutex> guard(mtx); //依然存在线程安全问题 要双重判断
			if (instance == nullptr) {
			/*1.开辟对象
			  2.构造对象
			  3.给instance赋值*/
				instance = new Singleton();
			}
		}
		return instance;
	}

private:
	//CPU再执行指令时 为了加快指令执行 会把线程共享的值拷贝一份到CPU的线程缓存中
	//因此要加一个volatile关键字 这样某一个线程给instance赋值时 其他线程可以立刻看到instance被改变了
	//因为线程不对其进行缓存了 
	static Singleton* volatile instance;   //2.定义一个唯一的类的实例对象 将其设置为一个指针
	Singleton() { //1.构造函数私有化

	}

	//为了防止产生其他实例 拷贝构造函数和 =运算符重载函数 也需要限制 delete掉
	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};
//静态成员变量 类内定义 类外初始化 在数据段上 
Singleton* Singleton::instance;
#endif

//懒汉式单例模式2：在程序执行getInstancel()才会初始化instance
class Singleton {
public:
	static Singleton* getInstance() { //3.获取类的唯一实例对象的接口方法 
		//静态变量 从程序运行开始就存在在数据段上 第一次运行到它时才会初始化
		//g++ -o run 单例模式.cpp -g    用gdb调试run
		//函数静态局部变量的初始化 在汇编指令上已经自动添加线程互斥指令了 因此是线程安全的
		static Singleton instance;   //2.定义一个唯一的类的实例对象
		return &instance;
	}

private:
	
	Singleton() { //1.构造函数私有化

	}

	//为了防止产生其他实例 拷贝构造函数和 =运算符重载函数 也需要限制 delete掉
	Singleton(const Singleton&) = delete;
	Singleton& operator=(const Singleton&) = delete;
};


int main() {
	//指针的地址一模一样 因为是唯一的实例
	Singleton* p1 = Singleton::getInstance();
	Singleton* p2 = Singleton::getInstance();
	Singleton* p3 = Singleton::getInstance();

	//Singleton t = *p1;  不可以拷贝构造

	return 0;
}
