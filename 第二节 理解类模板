#include<iostream>
using namespace std;

//模板的非类型参数 必须是整数类型(整数或者地址/引用都可以)都是常量
template<typename T, int SIZE>
void sort(T *arr) {
	for (int i = 0; i < SIZE - 1; ++i) {
		for (int j = 0; j < SIZE - 1; ++j) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//类模板 => 实例化 => 模板类
template<typename T>
class SeqStack  { //模板名称 + 类型参数名称 = 类名称
public:
	//构造和析构函数名不用加类型参数列表<T> 其他地方出现都加上类型参数列表
	//使用
	SeqStack(int size = 10)
		: _pstack(new T[size])
		, _top(0)
		, _size(size)
	{}

	~SeqStack() {
		delete[] _pstack;
		_pstack = nullptr;
	}

	//重写拷贝构造
	SeqStack(const SeqStack<T>& stack)
		: _top(stack._top)
		, _size(stack._size) {
		_pstack = new T[_size];
		//不要用memcopy进行拷贝 编译器内置类型没事 但对象就不行了
		for (int i = 0; i < top; i++) {
			_pstack[i] = stack._pstack[i];
		}
	}

	//重写赋值函数
	SeqStack<T>& operator=(const SeqStack<T>& stack) {
		//1.防止自赋值
		if (this == &stack) {
			return *this;
		}

		//2.释放原来的空间
		delete[] _pstack;

		//3.拷贝信息
		_top = stack._top;
		_size = stack._size;

		_pstack = new T[_size];
		for (int i = 0; i < _top; i++) {
			_pstack[i] = stack._pstack[i];
		}
	}

	//入栈操作 类内声明 类外实现
	void push(const T& val); /*{
		if (full()) {
			expand();
		}

		_pstack[_top++] = val;
	}*/

	//出栈操作
	void pop() {
		if (empty()) {
			return;
		}
		--_top;
	}

	//对于只读方法 写成常方法 普通对象和常对象都可以调用
	//判断是否栈满
	bool full() const {
		return _top == _size;
	}

	//判断是否为空
	bool empty() const {
		return _top == 0;
	}

	//返回栈顶元素
	T top()const {
		if (empty()) {
			throw "stack is empty!";//抛出异常也代表函数逻辑结束
		}
		return _pstack[_top - 1];
	}

private:
	T *_pstack;
	int _top;
	int _size;

	//顺序栈底层数组按2倍方式进行扩容操作
	void expand() {
		T *temp = new T[_size * 2];
		for (int i = 0; i < _top; i++) {
			temp[i] = _pstack[i];
		}

		delete[] _pstack;
		_pstack = temp;
		_size = 2 * _size;
	}
};

//类外实现push成员方法
template<typename T>
void SeqStack<T>::push(const T& val) {
	if (full()) expand();
	_pstack[_top++] = val;
}


int main() {
	//类模板选择性实例化
	SeqStack<int> s1;
	s1.push(20);
	s1.push(78);
	s1.push(32);
	s1.push(15);
	s1.pop();
	cout << s1.top() << endl;

	return 0;
#if 0
	int arr[] = { 12, 5, 7, 89, 32, 31, 35 };

	const int size = sizeof(arr) / sizeof(arr[0]);
	sort<int, size>(arr); //也可以是sort<int

	for (auto val : arr) {
		cout << val << " ";
	}
	cout << endl;
#endif
} 
