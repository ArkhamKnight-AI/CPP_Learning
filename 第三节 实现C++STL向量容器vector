#include<iostream>
using namespace std;

//类模板 =》 实现一个C++ STL中的顺序容器 vector向量容器
/*
SeqStack
Queue

*/

template<typename T>
class vector {
public:
	vector(int size = 10) {
		_first = new T[size];
		_last = _first;
		_end = _first + size;
	}

	~vector() {
		delete[] _first;
		_first = _last = _end = nullptr;
	}

	//拷贝构造函数 不省略<T>
	vector(const vector<T>& rhs) {
		int size = rhs._end - rhs._first;
		_first = new T[size];
		//有效数据的长度
		int len = rhs._last - rhs._first;
		//对有效数据部分进行赋值操作
		for (int i = 0; i < len; i++) {
			_first[i] = rhs._first[i];
		}
		_last = _first + len;
		_end = _first + size;
	}

	//等号运算符=重载 返回引用是为了支持连续赋值
	vector<T> operator=(const vector<T> &rhs) {
		//防止自赋值
		if (this == &rhs) return;

		//释放原空间
		delete[] _first;

		//有效数据赋值 和拷贝构造一样
		int size = rhs._end - rhs._first;
		_first = new T[size];
		int len = rhs._last - rhs._first;
		for (int i = 0; i < len; i++) {
			_first[i] = rhs._first[i];
		}
		_last = _first + len;
		_end = _first + size;
	}

	//向容器末尾添加元素
	void push_back(const T& val) {
		if (full()) {
			expand();
		}

		*_last++ = val;
	}

	//从容器末尾删除元素
	void pop_back() {
		if (empty()) {
			return;
		}

		--_last;
	}

	//返回容器末尾元素的值
	T back() const {
		return *(_last - 1);
	}

	//判断是否满
	bool full() {
		return _last == _end;
	}

	//判断是否为空
	bool empty() {
		return _first == _last;
	}

	//返回元素个数
	int size() const {
		return _last - _first;
	}

private:
	T *_first; //指向数组起始的位置
	T *_last;  //指向数组中有效元素的后继位置
	T *_end;   //指向数组空间的后继位置

	//容器二倍扩容
	void expand() {
		int size = _last - _first;
		T * temp = new T[2 * size];
		
		//拷贝元素
		for (int i = 0; i < size; i++) {
			temp[i] = _first[i];
		}

		//释放原空间
		delete[] _first;

		_first = temp;
		_last = _first + size;
		_end = _first + 2 * size;
	}
};

int main() {
	vector<int> vec;
	for (int i = 0; i < 20; i++) {
		vec.push_back(rand() % 100 + 1);
	}

	while (!vec.empty()) {
		cout << vec.back() << " ";
		vec.pop_back();
	}

	return 0;
} 
