#include<iostream>
#include<typeinfo>
#include<string>
using namespace std;

/*
抽象类和普通类有什么区别？
一般把什么类设计成抽象类？
*/

/*
动物的基类 类->抽象实体类型
定义Animal的初衷 并不是让Animal抽象某个类型实体
1.string _name; 让所有的动物实体类通过继承Animal直接复用该属性
2.给所有的派生类保留统一的覆盖/重写接口

拥有纯虚函数的类 叫作抽象类
抽象类不能再实例化对象了，但是可以定义指针和引用变量
*/

//汽车的基类 抽象类
class Car {
public:
	Car(string name, double oil) : _name(name), _oil(oil) {}

	//获取汽车剩余油量还可以跑的公里数
	double getLeftMiles() {
		return _oil * this->getMilesPerGallon(); //发生动态绑定 基类指针指向派生类对象
	}

	//常方法 只读接口 获取名称
	string getName() const {
		return this->_name;
	}

protected:
	string _name;
	double _oil;
	virtual double getMilesPerGallon() = 0; //纯虚函数 不同汽车不同
};

class Benz : public Car {
public:
	Benz(string name, double oil) : Car(name, oil) {}

	double getMilesPerGallon() { return 20.0; };
};

class Audi : public Car {
public:
	Audi(string name, double oil) : Car(name, oil) {}

	double getMilesPerGallon() { return 18.0; };
};

class BMW : public Car {
public:
	BMW(string name, double oil) : Car(name, oil) {}

	double getMilesPerGallon() { return 19.0; };
};

//给外部提供一个获取汽车剩余里程数的API
double showCarLeftMiles(Car& car) {
	//因为Car中的this->getMilesPerGallon() 指针指向不同的派生类对象  发生动态绑定
	cout << car.getName() << " left miles: " << car.getLeftMiles() << "公里" << endl;
	return car.getLeftMiles(); //静态绑定 调用Car中的getLeftMiles方法 call Car::getLeftMiles
}

int main() {
	Benz c1("奔驰", 20);
	Audi c2("奥迪", 20);
	BMW c3("宝马", 20);

	showCarLeftMiles(c1);
	showCarLeftMiles(c2);
	showCarLeftMiles(c3);

	return 0;
}
