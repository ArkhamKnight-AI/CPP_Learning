#include<iostream>
#include<typeinfo>
using namespace std;

/*
问题一：哪些函数不能实现成虚函数？
问题二：虚析构函数  
*/

class Base {
public:
	Base(int data = 10) : ma(data) {
		//cout << "Base()" << endl;
	}
	//虚函数
	virtual void show() {
		cout << "Base::show()" << endl;
	}

	//虚析构函数
	virtual ~Base() {
		//cout << "~Base()" << endl;
	}

protected:
	int ma;
};

class Derive : public Base {
public:
	Derive(int data = 10) : Base(data), mb(data) {
		//cout << "Derive()" << endl;
	}
	//派生类中和基类中继承来的某个方法，如果参数名、参数列表和返回值都相同
	//且基类中是virtual方法 那么派生类的这个方法 自动处理为虚函数 写不写virtual都是 
	void show() {
		cout << "Derive::show()" << endl;
	}

protected:
	int mb;
};

int main() {
	/*Derive d(50);
	Base* pb = &d;
	pb->show(); 
	pb->show(10);*/

	Base b;
	Derive d;
	 
	b.show(); //虚函数  call Base::show
	d.show(); //虚函数  call Derive::show

	//动态绑定(必须由指针指向虚函数)
	Base* pb1 = &b;
	pb1->show();
	Base* pb2 = &d;
	pb2->show();

	//动态绑定(必须由引用变量调用虚函数)
	Base& rb1 = b;
	rb1.show(); 
	Base& rb2 = d;
	rb2.show();

	//动态绑定(虚函数通过指针或引用调用变量，才发生动态绑定)
	Derive* pd1 = &d;
	pd1->show();
	Derive& rd1 = d;
	rd1.show();

	Derive* pd2 = (Derive*)&b; 
	pd2->show();
	
	return 0;
}
