#include<iostream>
#include<thread>
#include<list>
#include<mutex>
#include<queue> //C++所有的STL容器都不是线程安全的 不能使用在多线程环境下
#include<condition_variable> //条件变量 进程间通信头文件
using namespace std;

/*
C++多线程编程 - 线程间的同步通信机制
多线程编程的两个问题：
1.线程间互斥
(1)竞态条件->临界区代码段->原子操作->互斥锁mutex->轻量级无所实现CAS
(2)Linux系统编程 strace ./a.out mutex -> pthread_mutex_t

2.线程间同步通信
(1)线程2的执行依赖于线程1是否执行完成 当线程1执行完时通知线程2执行
(2)生产者/消费者线程模型
*/

//定义互斥锁 做线程间互斥操作
std::mutex mtx;

//定义条件变量 做线程间同步通信操作	
std::condition_variable cv;

//达到这么一个效果：生产者生产一个物品 通知消费者来消费一个；
//消费完了，消费者同孩子生产者继续生产物品
class Queue {
public:
	//生产一个物件
	void put(int val) {
		unique_lock<std::mutex> lck(mtx);
		/*lock_guard<std::mutex> guard(mtx); 不用这句话！*/
		//que为空才继续生产
		while (!que.empty()) {
			//que不为空 生产者通知消费者来消费 消费完了再继续生产 
			//生产者线程应该释放mtx互斥锁 进入等待状态 否则消费者无法消费
			//(1)wait等待消费者 消费 (2)同时将锁释放掉 
			//不直接使用mtx是为了 防止在使用mtx时资源被释放了 造成死锁
			cv.wait(lck);
		}
		que.push(val);
		
		//通知其他线程 生产了一个物品 来消费吧
		//notify_one->通知另外一个线程
		//notify_all->通知其他(消费者)所有线程 其他线程得到该通知->就会从等待状态变为阻塞状态->获取互斥锁才能继续执行
		cv.notify_all();
		cout << "生产者 生产: " << val << "号物品" << endl;
	}

	//消费一个物件 这样写有问题 因为如果消费的很快 那么生产者来不及生生产
	int get() {
		//lock_guard<std::mutex> guard(mtx); 不用这句话！
		unique_lock<std::mutex> lck(mtx);
		while (que.empty()) {
			//消费者线程发现que是空的 通知生产者线程先生产物品 才能消费
			//1.进入等待状态 2.把互斥锁mutex释放
			cv.wait(lck);
		}
		int val = que.front();
		que.pop();
		//notify_all->通知其他(生产者)所有线程 其他线程得到该通知->就会从等待状态变为阻塞状态->获取互斥锁才能继续执行
		cv.notify_all();
		cout << "消费者 消费: " << val << "号物品" << endl;
		return val;
	}

private:
	queue<int> que;
};

//生产者线程
void producer(Queue* que) {
	for (int i = 1; i <= 10; i++) {
		que->put(i);	
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

//消费者线程
void consumer(Queue* que) {
	for (int i = 1; i <= 10; i++) {
		que->get();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

int main() {
	Queue que; //两个线程共享队列


	std::thread t1(producer, &que);
	std::thread t2(consumer, &que);

	t1.join();
	t2.join();
	return 0;
} 
