#include<iostream>
#include<typeinfo>
#include<string>
using namespace std;

/*
第一题
*/
//动物的基类
class Animal {
public:
	Animal(string name) : _name(name) {}
	virtual void bark() {}

protected:
	string _name;
};

//猫类
class Cat : public Animal {
public:
	Cat(string name) : Animal(name) {}
	void bark() { cout << _name << " bark: miao miao!" << endl; }
};

//狗类
class Dog : public Animal {
public:
	Dog(string name) : Animal(name) {}
	void bark() { cout << _name << " bark: wang wang!" << endl; }
};

//猪类
class Pig : public Animal {
public:
	Pig(string name) : Animal(name) {}
	void bark() { cout << _name << " bark: heng heng!" << endl; }
};


#if 0
int main() {
	Animal* p1 = new Cat("加菲猫");
	Animal* p2 = new Dog("二哈");

	int* p11 = (int*)p1;
	int* p22 = (int*)p2;

	int tmp = p11[0];
	p11[0] = p22[0];
	p22[0] = tmp;


	p1->bark();
	p2->bark();

	delete p1;
	delete p2;

	return 0;
}

/*
第二题
*/
class Base {
public:
	virtual void show(int i = 10) {
		cout << "call Base::show i:" << i << endl;
	}
};


class Derive : public Base {
public:
	virtual void show(int i = 20) {
		cout << "call Derive::show i:" << i << endl;
	}
};

int main() {
	Base* p = new Derive();
	//为什么显示的数是10？
	p->show(); //动态绑定 p指向派生类对象 取出的是派生类的vfptr 取出的是派生类的虚函数地址
	delete p;

	return 0;
}




/*
第三题
*/
class Base {
public:
	virtual void show() {
		cout << "call Base::show" << endl;
	}
};


class Derive : public Base {
private:
	void show() {
		cout << "call Derive::show" << endl;
	}
};

int main() {
	Base* p = new Derive();
	/*
	成员方法能不能调用，就是说方法的访问权限是不是
	*/
	//第三题 为什么把Derive中的show设置为private外界依然可以调用？
	//最终能调用到Derive::show 是在运行时期才确定的
	p->show();
	delete p;

	return 0;
}
#endif

/*
第四题
*/
class Base {
public:
	Base() {
		/*
		push ebp
		mov ebp, esp 把esp赋值给ebp
		sub esp, 4Ch 为当前函数开辟栈帧
		rep stos esp<->ebp 把当前函数栈帧初始化为0xCCCCCCCC(windows)
		vfptr <- &Base::vftable 将Base的虚函数表地址写入vfptr中
		*/
		cout << "call Base()" << endl;
		clear();
	}

	//把从this指针开始的地方内存全部赋值为0 大小为对象的大小
	void clear() {
		memset(this, 0, sizeof(*this));
	}

	virtual void show() {
		cout << "call Base::show()" << endl;
	}
};


class Derive : public Base {
public:
	Derive() {
		/*
		push ebp
		mov ebp, esp 把esp赋值给ebp
		sub esp, 4Ch 为当前函数开辟栈帧
		rep stos esp<->ebp 把当前函数栈帧初始化为0xCCCCCCCC(windows)
		vfptr <- &Derive::vftable 将Derive的虚函数表地址写入vfptr中
		*/
		cout << "call Derive()" << endl;
	}

	void show() {
		cout << "call Derive::show()" << endl;
	}
};

int main() {
	//Base* pb1 = new Base();
	//pb1->show(); //动态绑定
	//delete pb1;

	Base* pb2 = new Derive();
	pb2->show(); //动态绑定
	delete pb2;

	return 0;
}
