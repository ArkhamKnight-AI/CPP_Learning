#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

class SeqStack {
public:
	//构造函数 SeqStack s1; SeqStack s2(20);
	SeqStack(int size = 10) {//是可以带参数的 因此可以提供多个构造函数
		cout << this << " SeqStack()" << endl;
		_pstack = new int[size];
		_top = -1;
		_size = size;
	}

	//析构函数 
	~SeqStack() {//是不可以带参数的 有且只有一个析构函数
		cout << this << " ~SeqStack()" << endl;
		delete[] _pstack;
		_pstack = nullptr;
	}

	void push(int val) {
		if (full()) {
			resize();
		}

		_pstack[++_top] = val;
	}

	void pop() {
		if (empty()) return;
		--_top;
	}

	int top() {
		return _pstack[_top];
	}

	bool empty() {
		return _top == -1;
	}

	bool full() {
		return _top == _size - 1;
	}

	

private:
	int* _pstack;
	int _top;
	int _size;
	void resize() {
		int *ptmp = new int[_size * 2];
		for (int i = 0; i < _size; i++) {
			ptmp[i] = _pstack[i];
		} //memcpy(ptmp, _pstack, sizeof(int)* _size; realloc

		delete[] _pstack;
		_pstack = ptmp;
		_size = 2 * _size;
	}
};


int main() {
	SeqStack s(50);
	for (int i = 0; i < 15; i++) {
		s.push(rand() % 100);
	}

	while (!s.empty()) {
		cout << s.top() << endl;
		s.pop();
	}

	SeqStack s1(50); 
	s1.~SeqStack(); //析构函数调用后 我们说对象不存在了
	//s1.push(3); //堆内存的非法访问

	SeqStack* s2 = new SeqStack(30);
	//先调用ps->~SeqStack() + free(ps)
	delete s2;
	system("pause");
	return 0;
} 
